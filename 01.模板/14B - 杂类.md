### 随机化算法

### 模拟退火

# P1337 [JSOI2004] 平衡点 / 吊打XXX

## 题目描述

如图，有 $n$ 个重物，每个重物系在一条足够长的绳子上。

每条绳子自上而下穿过桌面上的洞，然后系在一起。图中 $x$ 处就是公共的绳结。假设绳子是完全弹性的（即不会造成能量损失），桌子足够高（重物不会垂到地上），且忽略所有的摩擦，求绳结 $x$ 最终平衡于何处。

**注意**：桌面上的洞都比绳结 $x$ 小得多，所以即使某个重物特别重，绳结 $x$ 也不可能穿过桌面上的洞掉下来，最多是卡在某个洞口处。

![](https://cdn.luogu.com.cn/upload/image_hosting/u20jvui9.png)

## 输入格式

文件的第一行为一个正整数 $n$（$1\le n\le 1000$），表示重物和洞的数目。

接下来的 $n$ 行，每行是 $3$ 个整数 $x_i, y_i, w_i$，分别表示第 $i$ 个洞的坐标以及第 $i$ 个重物的重量。（$-10000\le x_i,y_i\le10000, 0<w_i\le1000$）

## 输出格式

你的程序必须输出两个浮点数（保留小数点后三位），分别表示处于最终平衡状态时绳结 $x$ 的横坐标和纵坐标。两个数以一个空格隔开。

## 输入输出样例 #1

### 输入 #1

```
3
0 0 1
0 2 1
1 1 1
```

### 输出 #1

```
0.577 1.000
```

## 说明/提示

数据保证平衡点是唯一的，也就是说形如 $n=2$ 且两个物品质量相等的情况不会出现。
```c++
#include<iostream>
#include<cmath>
#include<cstdio>
#include<iomanip>
#define abs(x) ((x)>=0?(x):(-(x)))
using namespace std;
const double eps=1e-5;
int n;
double x,y;
bool XF=true,YF=true;
struct Pos{
    int x,y;
    int w;
}pos[1005];
void Mov(double move){
    double X,Y,dis;
    double f;
    X=Y=0;
    for(int i=1;i<=n;i++){
        dis=sqrt((x-pos[i].x)*(x-pos[i].x)+(y-pos[i].y)*(y-pos[i].y));
        if(dis==0)continue;
        X+=pos[i].w/dis*(pos[i].x-x);
        Y+=pos[i].w/dis*(pos[i].y-y);
    }
    f=sqrt(X*X+Y*Y);
    x+=move/f*X;
    y+=move/f*Y;
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin>>n;
    for(int i=1;i<=n;i++)
        cin>>pos[i].x>>pos[i].y>>pos[i].w;
    double move=5000,tx,ty;
    while(true){
        tx=x;
        ty=y;
        Mov(move);
        if(abs(tx-x)<eps&&abs(ty-y)<eps)
            break;
        if((XF!=(x>tx))||(YF!=(y>ty))){
            XF=!x>tx;
            YF=!y>ty;
            move=move*0.9;
        }
    }
    printf("%.3f %.3f",x,y);
}
```
```C++
#include <iostream>
#include <cmath>
#include <cstdio>
#include <iomanip>
#include <ctime> // 1. 包含头文件

// 使用 using namespace std; 在竞赛中很常见，但在大型项目中不推荐
using namespace std;

// 题目本身精度要求不高，可以去掉 abs 宏定义和 eps 常量

struct Pos {
    int x, y;
    int w;
} pos[1005];

int n;
double current_x = 0, current_y = 0; // 使用更清晰的变量名

// 计算在 (x, y) 点的“能量”或者说“势能”，我们的目标是让它最小
// Mov 函数本质上是在计算这个能量函数的梯度方向
double calculate_energy(double x, double y) {
    double total_energy = 0;
    for (int i = 1; i <= n; i++) {
        double dx = x - pos[i].x;
        double dy = y - pos[i].y;
        total_energy += sqrt(dx * dx + dy * dy) * pos[i].w;
    }
    return total_energy;
}

void simulated_annealing() {
    // 2. 设定时间限制（例如：0.95秒）
    const double TIME_LIMIT = 0.95; 
    
    // 初始化一个随机起点，通常比 (0,0) 更好
    for(int i = 1; i <= n; ++i) {
        current_x += pos[i].x;
        current_y += pos[i].y;
    }
    current_x /= n;
    current_y /= n;

    double best_x = current_x;
    double best_y = current_y;
    double best_energy = calculate_energy(best_x, best_y);

    double move = 5000.0; // 初始步长（类似模拟退火的初始温度）

    // 3. 将循环条件改为时间控制
    while ((double)clock() / CLOCKS_PER_SEC < TIME_LIMIT) {
        double grad_x = 0, grad_y = 0;
        
        // 计算梯度（受力方向）
        for (int i = 1; i <= n; i++) {
            double dx = current_x - pos[i].x;
            double dy = current_y - pos[i].y;
            double dis = sqrt(dx * dx + dy * dy);
            if (dis > 1e-9) { // 避免除以零
                grad_x += pos[i].w * dx / dis;
                grad_y += pos[i].w * dy / dis;
            }
        }

        // 沿着梯度的反方向移动一小步，因为我们要求最小值
        // 这里你的原代码是 grad_x += pos[i].w/dis*(pos[i].x-x)，我这里等价地改成了 dx
        double next_x = current_x - move * grad_x;
        double next_y = current_y - move * grad_y;
        
        double current_energy = calculate_energy(current_x, current_y);
        double next_energy = calculate_energy(next_x, next_y);

        // 如果新位置更好，或者按一定概率接受更差的位置（模拟退火思想）
        // 这里简化为贪心，只在更好时移动，因为你的原代码就是贪心
        if (next_energy < current_energy) {
             current_x = next_x;
             current_y = next_y;
             if (next_energy < best_energy) {
                 best_energy = next_energy;
                 best_x = next_x;
                 best_y = next_y;
             }
        }
        
        // 4. 使用平滑的步长衰减
        move *= 0.999;
    }

    // 循环结束后，输出找到的最优解
    printf("%.3f %.3f\n", best_x, best_y);
}

int main() {
    // 使用 stdio 同步可以防止在混合使用 cin/cout 和 printf/scanf 时出错
    // 如果只用 cin/cout，关闭同步可以加速
    // ios::sync_with_stdio(false);
    // cin.tie(0);
    
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> pos[i].x >> pos[i].y >> pos[i].w;
    }
    
    simulated_annealing(); // 调用算法

    return 0;
}
```

随机化思想也是常常考察的点。有时候简单加一个随机化就能让出题人没法卡你，从而通过。

### 反悔贪心

#### CF865D Buy Low Sell High

##### 题目描述

你可以完美地预测某只股票接下来 $N$ 天的价格，你想利用这一知识盈利，但你每天只想买卖一股，这表明你每天要么什么都不干，要么买入一股，要么卖出一股。起初你没有股票，你也不能在没有股票时卖出股票。你希望在第 $N$ 天结束时不持有股票，并最大化盈利。

##### 输入格式

第一行一个整数 $N$（$2 \le N \le 3 \times 10^5$），表示天数。

接下来一行 $N$ 个整数 $p_1,p_2,\dots p_N$（$1 \le p_i \le 10^6$），表示第 $i$ 天的股价。

##### 输出格式

输出你第 $N$ 天结束时的最大盈利。

###### 样例解释

在股价为 $5,4$ 时各买入一股，在股价为 $9,12$ 时各卖出一股，接着在股价为 $2$ 时买入一股，股价为 $10$ 时卖出一股，总收益为 $20$。

Translated by uid $408071$。

##### 输入输出样例 #1

###### 输入 #1

```
9
10 5 4 7 9 12 6 2 10
```

###### 输出 #1

```
20
```

##### 输入输出样例 #2
###### 输入 #2

```
20
3 1 4 1 5 9 2 6 5 3 5 8 9 7 9 3 2 3 8 4
```

###### 输出 #2

```
41
```
```c++
#include<iostream>
#include<queue>
#define ll long long
using namespace std;
ll ans;
priority_queue<int,vector<int>,greater<int>>q;
int main()
{
  int n;
  cin>>n;
  for(int i=1;i<=n;i++)
  {
    int temp;
    cin>>temp;
    if(!q.empty()&&q.top()<temp)
    {
      ans+=temp-q.top();
      q.pop();
      q.push(temp);
    }
    q.push(temp);
  }
  cout<<ans<<'\n';
}
```
# P2949 [USACO09OPEN] Work Scheduling G

## 题目描述

农夫约翰有很多工作要做！为了高效地经营农场，他必须从他所做的每一项工作中赚取利润，每项工作只需要一个时间单位。

他的工作日从时间 $0$ 开始，总共有 $10^9$ 个时间单位。他目前可以从 $N$ ($1 \leq N \leq 10^5$) 项工作中选择要做的工作，这些工作被方便地编号为 $1$ 到 $N$。

虽然理论上他有可能完成所有 $N$ 项工作，但实际上这是极不可能的，因为他在任何一个时间单位内只能完成一项工作，而截止日期通常会导致他无法完成所有任务。

第 $i$ 项工作的截止时间为 $D_i$ ($1 \leq D_i \leq 10^9$)。如果他在截止时间前完成第 $i$ 项工作（如果当前时间为 $t$，那么仅当 $D_i > t$ 的时候他能做这个任务，完成后 $t \rightarrow t+1$），他将获得 $P_i$ ($1 \leq P_i \leq 10^9$) 的利润。

给定一系列工作和截止日期，FJ 能够获得的最大总利润是多少？答案可能无法容纳在 $32$ 位整数中。

## 输入格式

第一行输入一个整数 $N$，意义见题目描述。

第二行到第 $N+1$ 行：第 $i+1$ 行包含两个用空格分隔的整数：$D_i$ 和 $P_i$

## 输出格式

只有一个数字，表示 FJ 能够获得的最大利润。

## 输入输出样例 #1

### 输入 #1

```
3 
2 10 
1 5 
1 7
```

### 输出 #1

```
17
```

## 说明/提示

在时间 $1$ 完成工作 $3$ $\left(1,7\right)$，在时间 $2$ 完成工作 $1$ $\left(2,10\right)$ 以最大化收益，最后收益为 $7+10=17$。

（由 ChatGPT 4o 翻译）
```c++
#include<bits/stdc++.h>
#define ll long long
#define pb push_back
#define eb emplace_back
#define mp make_pair
using namespace std;
const int N=2e5+10;
const int mod=998244353;
const int inf=0x3f3f3f3f;
typedef pair<int,int> pii;
typedef pair<ll,ll> pll;
typedef vector<pair<int,int>> vpii;
struct node{
    int tim,val;
    bool operator<(const node &b)const{
        return tim<b.tim;
    }
}w[N];
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n;
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>w[i].tim>>w[i].val;
    }
    sort(w+1,w+n+1);
    ll ans=0;
    priority_queue<int,vector<int>,greater<int>>q;
    for(int i=1;i<=n;i++){
        if(w[i].tim<=q.size()){
            if(w[i].val>q.top()){
                ans-=q.top();
                q.pop();
                q.push(w[i].val);
                ans+=w[i].val;
            }
        }else {
                q.push(w[i].val);
                ans+=w[i].val;
            }
    }
    cout<<ans<<endl;
}
```
# AT_agc018_c [AGC018C] Coins

题意翻译
有 $x+y+z$ 个人，第 $i$ 个人有 $A_i$ 个金币，$B_i$个银币，$C_i$  个铜币。

要选出 $x$ 个人获得其金币，选出 $y$ 个人获得其银币，选出 $z$ 个人获得其铜币。在不重复选某个人的情况下，最大化获得的币的总数。$x+y+z≤10^5$。

#### 题解

看完题可以发现这是一个类似于[NOI2019]序列的题目，自然考虑反悔贪心。

vp赛时本蒟蒻本来先考虑先选$x$个金币，再选$y$个银币，最后选$z$个铜币，在选每种币的时候把所有可以反悔的情况都开个堆维护，但是发现这样太复杂了，而且根本就没有利用总人数$n=x+y+z$的性质。

考虑因为$n=x+y+z$，所以可以先让所有人随便选一种硬币，保证$x$个人选了金币，$y$个人选了银币，$z$个人选了铜币，我们再进行反悔。

为方便，下文用$x->y$表示一个选了金币的人换成了银币，$y->z,z->x$等同理。

此时因为我们并不能改变选某种硬币的人数，所以我们能进行的变换只有类似于$x->y$，$x->z$，$z->x$这种环状的变换。略加思考可以发现只有$5$种情况：

$1.x->y,y->z,z->x$

$2.x->z,z->y,y->x$

$3.x->y,y->x$

$4.y->z,z->y$

$5.x->z,z->x$

然后一个人能进行的变换也只有$6$种，因此维护$6$个堆，然后每次对这$5$种情况找一个最大值即可（最大值$<=0$时答案达到最大值）

```cpp
//W4P3R
#include<bits/stdc++.h>
#define inf 1e9
#define eps 1e-6
#define mp make_pair
#define pb push_back
#define re register ll
#define fr first
#define sd second
#define pa pair<ll,ll>
#define FOR(i,a,b) for(re i=a;i<=b;i++)
#define REP(i,a,b) for(re i=a;i>=b;i--)
#define MEM(a) memset(a,0,sizeof(a))
#define N 100010
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef double db;
inline ll read()
{
	char ch=getchar();
	ll s=0,w=1;
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){s=s*10+ch-'0';ch=getchar();}
	return s*w;
}
inline ll lowbit(ll x){return x&(-x);}
ll n,X,Y,Z;
ll a[N],b[N],c[N];
ll vis[N],ans;
priority_queue<pa,vector<pa>,less<pa> >q1,q2,q3,q4,q5,q6;
inline void add(ll x)
{
	q1.push(mp(b[x]-a[x],x));//x->y
	q2.push(mp(c[x]-b[x],x));//y->z
	q3.push(mp(a[x]-c[x],x));//z->x
	
	q4.push(mp(c[x]-a[x],x));//x->z
	q5.push(mp(b[x]-c[x],x));//z->y
	q6.push(mp(a[x]-b[x],x));//y->x
}
int main()
{
	//ios::sync_with_stdio(false);
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	X=read(),Y=read(),Z=read();n=X+Y+Z;
	FOR(i,1,n)a[i]=read(),b[i]=read(),c[i]=read();
	FOR(i,1,X)vis[i]=1,ans+=a[i];
	FOR(i,X+1,X+Y)vis[i]=2,ans+=b[i];
	FOR(i,X+Y+1,X+Y+Z)vis[i]=3,ans+=c[i];
	FOR(i,1,n)add(i);
	while(true)
	{
		while(!q1.empty()&&vis[q1.top().sd]!=1)q1.pop();
		while(!q2.empty()&&vis[q2.top().sd]!=2)q2.pop();
		while(!q3.empty()&&vis[q3.top().sd]!=3)q3.pop();
		
		while(!q4.empty()&&vis[q4.top().sd]!=1)q4.pop();
		while(!q5.empty()&&vis[q5.top().sd]!=3)q5.pop();
		while(!q6.empty()&&vis[q6.top().sd]!=2)q6.pop();//反悔贪心在每次取值时弹出不合法状态往往更好写 
		
		ll v1=(q1.empty()?-inf:q1.top().fr),v2=(q2.empty()?-inf:q2.top().fr),v3=(q3.empty()?-inf:q3.top().fr);
		ll v4=(q4.empty()?-inf:q4.top().fr),v5=(q5.empty()?-inf:q5.top().fr),v6=(q6.empty()?-inf:q6.top().fr);
		ll maxn=0,t=0;
		if(v1+v2+v3>maxn)maxn=v1+v2+v3,t=1;//情况1
		if(v4+v5+v6>maxn)maxn=v4+v5+v6,t=2;//情况2
		if(v1+v6>maxn)maxn=v1+v6,t=3;//情况3
		if(v2+v5>maxn)maxn=v2+v5,t=4;//情况4
		if(v3+v4>maxn)maxn=v3+v4,t=5;//情况5
		if(!maxn)break;ans+=maxn;
		if(t==1)
		{
			ll x=q1.top().sd,y=q2.top().sd,z=q3.top().sd;
			vis[x]=2,vis[y]=3,vis[z]=1;
			add(x);add(y);add(z);
		}
		if(t==2)
		{
			ll x=q4.top().sd,y=q5.top().sd,z=q6.top().sd;
			vis[x]=3;vis[y]=2;vis[z]=1;
			add(x);add(y);add(z);
		}
		if(t==3)
		{
			ll x=q1.top().sd,y=q6.top().sd;
			vis[x]=2;vis[y]=1;
			add(x);add(y);
		}
		if(t==4)
		{
			ll x=q2.top().sd,y=q5.top().sd;
			vis[x]=3;vis[y]=2;
			add(x);add(y);
		}
		if(t==5)
		{
			ll x=q3.top().sd,y=q4.top().sd;
			vis[x]=1;vis[y]=3;
			add(x);add(y);
		}
	}
	cout<<ans<<'\n';
	return 0;
}
//gl

``` 
#### CF730I Olympiad in Programming and Sports
有 n 个学生每人有两种技能，分别是 a,b 表示编程能力和运动能力。你需要将他们分为两个团队分别参加编程比赛和体育比赛，编程团队有 p 人，体育团队有 s 人，一个学生只能参加其中一项。每个团队的力量是其成员在对应领域能力总和，请问如何分配能使得两个团队的实力和最大？
```c++
#include<bits/stdc++.h>
#define ll long long
#define pb push_back
#define eb emplace_back
#define mp make_pair
using namespace std;
const int N=2e5+10;
const int mod=998244353;
const int inf=0x3f3f3f3f;
typedef pair<int,int> pii;
typedef pair<ll,ll> pll;
typedef vector<pair<int,int>> vpii;
void solve(){
    int n,p,s;
    cin>>n>>p>>s;
    vector<int>a(n),b(n),vis(n);
    priority_queue<pair<int,int>>x,y,z;
    for(int i=0;i<n;i++)cin>>a[i],x.push({a[i],i});
    for(int i=0;i<n;i++)cin>>b[i],y.push({b[i],i});
    int ans=0;
    
    for(int i=1;i<=p;i++){
        ans+=x.top().first;
        int id=x.top().second;
        x.pop();
        vis[id]=1;
        z.push({b[id]-a[id],id});
    }
    for(int i=1;i<=s;i++){
        while(y.size()&&vis[y.top().second])y.pop();
        while(x.size()&&vis[x.top().second])x.pop();
        while(z.size()&&vis[z.top().second]!=1)z.pop();
        int id1=-1,id2=-1;
        int tmp=0,typ=0;
        if(y.size())tmp=y.top().first,typ=1,id1=y.top().second;
        if(x.size()&&z.size()){
            //cout<<x.top().first<<" "<<z.top().first<<endl;
            if(x.top().first+z.top().first>tmp){
                tmp=x.top().first+z.top().first;
                typ=2;
                id1=x.top().second;
                id2=z.top().second;
                //out<<id1<<" "<<id2<<endl;
            }
        }
        ans+=tmp;
        //cout<<tmp<<endl;
        if(typ==1){
            vis[id1]=2;
            y.pop();
        }
        else if(typ==2){
            vis[id1]=1,vis[id2]=2;
            x.pop(),z.pop();
            z.push({b[id1]-a[id1],id1});
        }
    }
    cout<<ans<<endl;
    // for(int i=0;i<n;i++)cout<<vis[i]<<" ";
    // cout<<'\n';
    for(int i=0;i<n;i++){
        if(vis[i]==1){
            cout<<i+1<<" ";
        }
    }
    cout<<'\n';
    for(int i=0;i<n;i++){
        if(vis[i]==2){
            cout<<i+1<<" ";
        }
    }
    cout<<'\n';
}
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    int t=1;
    while(t--){
        solve();
    }
}
```

### wqs二分
