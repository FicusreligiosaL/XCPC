###随机化算法
###模拟退火
# P1337 [JSOI2004] 平衡点 / 吊打XXX

## 题目描述

如图，有 $n$ 个重物，每个重物系在一条足够长的绳子上。

每条绳子自上而下穿过桌面上的洞，然后系在一起。图中 $x$ 处就是公共的绳结。假设绳子是完全弹性的（即不会造成能量损失），桌子足够高（重物不会垂到地上），且忽略所有的摩擦，求绳结 $x$ 最终平衡于何处。

**注意**：桌面上的洞都比绳结 $x$ 小得多，所以即使某个重物特别重，绳结 $x$ 也不可能穿过桌面上的洞掉下来，最多是卡在某个洞口处。

![](https://cdn.luogu.com.cn/upload/image_hosting/u20jvui9.png)

## 输入格式

文件的第一行为一个正整数 $n$（$1\le n\le 1000$），表示重物和洞的数目。

接下来的 $n$ 行，每行是 $3$ 个整数 $x_i, y_i, w_i$，分别表示第 $i$ 个洞的坐标以及第 $i$ 个重物的重量。（$-10000\le x_i,y_i\le10000, 0<w_i\le1000$）

## 输出格式

你的程序必须输出两个浮点数（保留小数点后三位），分别表示处于最终平衡状态时绳结 $x$ 的横坐标和纵坐标。两个数以一个空格隔开。

## 输入输出样例 #1

### 输入 #1

```
3
0 0 1
0 2 1
1 1 1
```

### 输出 #1

```
0.577 1.000
```

## 说明/提示

数据保证平衡点是唯一的，也就是说形如 $n=2$ 且两个物品质量相等的情况不会出现。
```c++
#include<iostream>
#include<cmath>
#include<cstdio>
#include<iomanip>
#define abs(x) ((x)>=0?(x):(-(x)))
using namespace std;
const double eps=1e-5;
int n;
double x,y;
bool XF=true,YF=true;
struct Pos{
    int x,y;
    int w;
}pos[1005];
void Mov(double move){
    double X,Y,dis;
    double f;
    X=Y=0;
    for(int i=1;i<=n;i++){
        dis=sqrt((x-pos[i].x)*(x-pos[i].x)+(y-pos[i].y)*(y-pos[i].y));
        if(dis==0)continue;
        X+=pos[i].w/dis*(pos[i].x-x);
        Y+=pos[i].w/dis*(pos[i].y-y);
    }
    f=sqrt(X*X+Y*Y);
    x+=move/f*X;
    y+=move/f*Y;
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin>>n;
    for(int i=1;i<=n;i++)
        cin>>pos[i].x>>pos[i].y>>pos[i].w;
    double move=5000,tx,ty;
    while(true){
        tx=x;
        ty=y;
        Mov(move);
        if(abs(tx-x)<eps&&abs(ty-y)<eps)
            break;
        if((XF!=(x>tx))||(YF!=(y>ty))){
            XF=!x>tx;
            YF=!y>ty;
            move=move*0.9;
        }
    }
    printf("%.3f %.3f",x,y);
}
```
```C++
#include <iostream>
#include <cmath>
#include <cstdio>
#include <iomanip>
#include <ctime> // 1. 包含头文件

// 使用 using namespace std; 在竞赛中很常见，但在大型项目中不推荐
using namespace std;

// 题目本身精度要求不高，可以去掉 abs 宏定义和 eps 常量

struct Pos {
    int x, y;
    int w;
} pos[1005];

int n;
double current_x = 0, current_y = 0; // 使用更清晰的变量名

// 计算在 (x, y) 点的“能量”或者说“势能”，我们的目标是让它最小
// Mov 函数本质上是在计算这个能量函数的梯度方向
double calculate_energy(double x, double y) {
    double total_energy = 0;
    for (int i = 1; i <= n; i++) {
        double dx = x - pos[i].x;
        double dy = y - pos[i].y;
        total_energy += sqrt(dx * dx + dy * dy) * pos[i].w;
    }
    return total_energy;
}

void simulated_annealing() {
    // 2. 设定时间限制（例如：0.95秒）
    const double TIME_LIMIT = 0.95; 
    
    // 初始化一个随机起点，通常比 (0,0) 更好
    for(int i = 1; i <= n; ++i) {
        current_x += pos[i].x;
        current_y += pos[i].y;
    }
    current_x /= n;
    current_y /= n;

    double best_x = current_x;
    double best_y = current_y;
    double best_energy = calculate_energy(best_x, best_y);

    double move = 5000.0; // 初始步长（类似模拟退火的初始温度）

    // 3. 将循环条件改为时间控制
    while ((double)clock() / CLOCKS_PER_SEC < TIME_LIMIT) {
        double grad_x = 0, grad_y = 0;
        
        // 计算梯度（受力方向）
        for (int i = 1; i <= n; i++) {
            double dx = current_x - pos[i].x;
            double dy = current_y - pos[i].y;
            double dis = sqrt(dx * dx + dy * dy);
            if (dis > 1e-9) { // 避免除以零
                grad_x += pos[i].w * dx / dis;
                grad_y += pos[i].w * dy / dis;
            }
        }

        // 沿着梯度的反方向移动一小步，因为我们要求最小值
        // 这里你的原代码是 grad_x += pos[i].w/dis*(pos[i].x-x)，我这里等价地改成了 dx
        double next_x = current_x - move * grad_x;
        double next_y = current_y - move * grad_y;
        
        double current_energy = calculate_energy(current_x, current_y);
        double next_energy = calculate_energy(next_x, next_y);

        // 如果新位置更好，或者按一定概率接受更差的位置（模拟退火思想）
        // 这里简化为贪心，只在更好时移动，因为你的原代码就是贪心
        if (next_energy < current_energy) {
             current_x = next_x;
             current_y = next_y;
             if (next_energy < best_energy) {
                 best_energy = next_energy;
                 best_x = next_x;
                 best_y = next_y;
             }
        }
        
        // 4. 使用平滑的步长衰减
        move *= 0.999;
    }

    // 循环结束后，输出找到的最优解
    printf("%.3f %.3f\n", best_x, best_y);
}

int main() {
    // 使用 stdio 同步可以防止在混合使用 cin/cout 和 printf/scanf 时出错
    // 如果只用 cin/cout，关闭同步可以加速
    // ios::sync_with_stdio(false);
    // cin.tie(0);
    
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> pos[i].x >> pos[i].y >> pos[i].w;
    }
    
    simulated_annealing(); // 调用算法

    return 0;
}
```

随机化思想也是常常考察的点。有时候简单加一个随机化就能让出题人没法卡你，从而通过。